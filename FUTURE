New features for the Hildon Application Manager
===============================================

* Avoiding invisible interaction flows [mario]

Currently, it is possible to start an interaction flow (using
start_interaction_flow, say) without immediatly popping up a dialog
that would represent this interaction flow.

The delays used to be shortish, but they can now be quite long because
of big OS updates.

For example, opening the "Details" dialog for a "OS2008 Reloaded"
update can take a couple of seconds and there is therefore a long gap
between activating the button and the dialog opening.

Two things need to be done: the preparing of large operations needs to
be sped up, and potential gaps in the UI flow need to be plugged.
This feature is about pluggin the gaps in the UI.

First, the gaps need to be identified: look for uses of
start_interaction_flow etc and make sure that no operation is
performed between calling this start_interaction_flow function and
showing the first dialog.

No apt-worker request can be assumed to be quick (not even things like
APTCMD_GET_CATALOGUES that don't require significant processing) since
the apt-worker might be busy with something else before being able to
process a quick request.

If information from the apt-worker is needed to construct the dialog,
the code could be changed to show an 'empty' dialog with insensitive
buttons and a "updating" progress banner.  When the information
arrives, the dialog should be filled and the buttons should be made
sensitive.

Please prepare a list of these cases so that we can quickly see
whether this approach needs to be refined in some cases.

The details dialog is already a bit special: do not make the "Close"
button insensitive while waiting for more information from the
apt-worker.  It should be possible to close the dialog at any time.
The apt-worker request does not need to be canceled in that case, but
the eventual reply should be safely ignored, of course.

Maybe some apt-worker requests need to split in two so that the first
half can finish quickly.

* Speeding up preparation of large operations [mvo]

[ Also see the previous feature. ]

Computing an update (calling mark_install in the apt-worker, etc) used
to be quick enough, but now it can be quite slow since we have large
OS updates.  This needs to be sped up.

When performing an installation, the frontend asks the backend to
compute the same update three times or so.  Either the frontend needs
to ask less often or the backend should keep the last operation in the
cache.

* Automatic recovery after an interrupted operation [mvo]

When a package management operation is interrupted abruptly, the
system might still be able to recover by trying to complete the update
on the next boot.

To acomplish this, the apt-worker is run in a new "rescue" mode on
every boot, as early as possible.

The rescue mode will determine whether any repairs are needed, and if
so, will attempt them.  Determining whether any repairs are needed
must be fast.

Steps:

- Move flash-and-reboot functionality into apt-worker so that it is
  available during repairs.

- Have the apt-worker write a journal for each INSTALL_PACKAGE
  operation.  The journal entry should contain the package name and
  the location with the packages.

- Add the "rescue" command line command which will look at the
  journal.  If the journal is non-empty, try to finish it.

Finishing the journal means first running "dpkg --configure -a",
ignoring any errors, and then redoing the installation described in
the journal.  Then, "dpkg --configure -a --force-all" is run, for good
measure.

If any packages would need to be downloaded, the repair is not done.

If the required, the device is rebooted, or flash-and-reboot is run at
the end, or booting is allowed to continue.

UI of this to be decided.


* Pushing of messages into the update notifier plugin [felipe]

Product management wants to be able to notify the user about
significant new applications that are available for theri internet
tablets.  They want to use the existing update notifier statusbar
plugin for that.

The update-notifier plugin should be able to watch a given URI and
present information from this URL via the statusbar icon.  When the
contents of the resource behind the URI has changed, the icon should
start blinking; when the user taps it, the blinking should stop and a
menu with information from the resource should open; when the user
selects an action from the menu, the icon should disappear.

The original update notification functionality of the statusbar plugin
should have priority: the resource watching functionality should only
control the icon when the update notification functionality would hide
the icon.

The URI should be checked at the same time as the checking for
updates.

Final details about the UI and the content of the watched resource are
upcoming.  The menu should have two action items in it: "Tell me
more", which opens the web browser with a given URI, and "No thanks",
which does nothing else than hide the icon.

To get started, the content of the resource should be assumed to be a
xexp of the form:

  <info>
   <text>Blah, blah</text>
   <uri>http://www.example.com/</uri>
  </info>

This should yield a menu like this:

  Blah, blah                <- insensitive
  -----------
  Show me more              <- open browser on http://www.example.com
  No, thanks.               <- hides icon

It is important that checking the URI does not block the process.  If
needed, a separate process should be spawned (no threads, please).


* Better handling and reporting of dependency and conflict issues. [--]

We need to get better at explaining the reasons why a given operation
can not be performed so that the user has a chance of taking
corrective actions.

Also, since we now have a visible package that represents the
operating system, we can be more agressive with making changes to
invisible packages: the operating system package will make sure (via
its dependencies) that we don't kill the device by accidentally
uninstalling or upgrading important packages.

The general principle that this feature aims to implement is that the
user-visible packages are managed completely manually by the user, and
the user-invisible packages are managed completely automatically.

Thus, the general behavior of the Application Manager should be the
following:

 1 When the user requests to install or remove a package, the AM will
   plan to do any necessary (and possible) changes to all the packages
   to satisfy the request of the user.  These changes can include
   installing additional packages, removing already installed
   packages, or upgrading installed packages to a newer version.

   The AM should try at least as hard as apt-get to find a solution,
   but it should favor upgrading over removing.

   For example, instead of removing the OS meta package in order to
   upgrade some invisible packages, it should prefer to upgrade the OS
   meta package (and pull in the complete OS update).

 2 Once a solution has been found, and it requires changes to user
   visible packages, the user has to confirm these changes.

 3 When no solution has been found, the only reasons for this can be
   that the OS package would need to be removed, or that packages are
   needed that are not available from any repository.  This can be
   explained easily, I'd assume.

The following steps might be appropriate:

- Investigate which algorithms apt-get and aptitude use for "install
  <pkg>" and "remove <pkg>" and make them available in the apt-worker
  (preferably aptitudes).  Don't remove the existing algorithms.

- Add a red-pill setting that makes the apt-worker use those
  algorithms.

- Tune the algorithms to favor upgrading over removal, as explained
  under point 1 above.

- Add suitable problem detection and reporting algorithms that
  implement points 1 and 2 from above.  But instead of letting the
  user confirm the planned changes to visible packages, we just report
  these changes as errors, or do them automatically:

  - If a visible package A would be removed and the user is doing a
    "uninstall B" operation, we report "B is needed by A."

  - If a visible package A would be removed and the user is doing a 
    "install B" operation, we report "B conflicts with A."

  - If a visible package A would be newly installed or upgraded and
    the user is doing a "install B" operation, and package A is not
    the OS, we just do the upgrade.

  - If package A from the last paragraph is the OS, we report "B needs
    A to be installed first".

  - If a visible package A would be newly installed or upgraded and
    the user is doing a "uninstall B" operation, we report "B is
    needed by A".

  The reports should always include the respective versions of the
  packages.

- Experiment!  Make a decision whether we can ship with these
  algorithms enabled by default or whether we can get the next step
  done as well:

- Show the thing to the UI people so that we can come up with the
  right way to do it: letting users confirm the changes to the visible
  packages.


* Automatic checking for updates in the background

- APTCMD_UPDATE_PACKAGE_CACHE is renamed to APTCMD_CHECK_UPDATES and
  made cancellable at every point, not just during downloading.  Also,
  it should not report errors at the end of the operation but store
  them away for later retrieval.  It should also collect the
  information necessary for the notification plugin (number of
  available updates, classified into "OS", "Nokia", and "Other") and
  store it away.

- The apt-worker should be able to be invoked from the command-line to
  perform the APTCMD_CHECK_UPDATES operation.  When invoked in this
  way, the operation should be cancellable (using SIGINT, say).  Also,
  it should refuse to run when the apt-worker is already running as
  the backend for the AM.

- When the apt-worker starts in its usual role as the backend for the
  Application Manager, it should cancel already running instances of
  itself that have been started from the command line.

- The Application Manager should have the new "Update All" button in
  the "Check for Updates" view.

- There is a new component: the notification statusbar plugin.  The
  notification plugin runs always and is in one of three different
  states: invisible/visible/blinking.

- The notification plugin invokes the apt-worker in comand-line mode
  to perform APTCMD_CHECK_UPDATES 'occasionally'.  Such a operation is
  attempted when the following conditions are all true:

  - The last APTCMD_CHECK_UPDATES has stopped (successfully or not,
    interrupted or not) 24 hours or more ago.

  - There is a active WLAN connection (no Bluetooth).

  When the APTCMD_CHECK_UPDATES can not be performed because the
  apt-worker is already running as the backend for the Application
  Manager, the notification plugin should send a message to the AM
  that requests it to do the operation instead.

- When the Application Manager receives such a request, it will
  perform it as early as possible.  It is possible to do it when the
  AM has been idle for at least one minute.  Idle means: no
  interaction flow is active.

- The state changes of the plugin are as follows:

  - when the user taps it (to open the menu), it stops blinking.

  - when a APTCMD_CHECK_UPDATES initiated by the plugin itself was
    sucessful and updates are available and the plugin was invisible
    before, it starts blinking.

  - when the "Check for updates" view in the Application Manager is
    opened, or when the user invokes the Application Manager from the
    plugin menu and the "Check for Updates" view is already open, the
    plugin becomes invisible.

- The notification plugin should store its visibility state
  permanently across reboots.

- The notification plugin should be notified by apt-worker whenever
  the information for it changes, and the plugin should then read that
  information and reconstruct its menu.
